/*
 Copyright 2015 eBusiness Information
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
 http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */
/**
 * Created by Lo√Øc Ortola on 16/10/2015.
 * MBTiles Generator service
 */
// Conf & Utils
var Conf = require('../conf/conf');
var ProjectionUtils = require('../util/projection-utils');
// Classes
var Tile = require('../model/tile');
var Step = require('step');
var HashMap = require('hashmap');
// Logging
var debug = require('debug')('mbt:service:mbtile-generator-service');
// Imports
var fs = require('fs');
var sqlite3 = require('sqlite3').verbose();
var http = require('http');
var mapper = getMapper(Conf.tileServer.type);

// Number of requests for each step set.
var STEP_REQUEST_SIZE = 500;


/**
 * Get the appropriate mapper
 * @param type the tile server type
 */
function getMapper(type) {
  if (type === 'osm') {
    return require('../mapper/osm-mapper');
  } else if (type === 'bing') {
    return require('../mapper/bing-mapper');
  }
  throw new Error('Wrong tile mapper specified. Please specify an appropriate mapper type in Conf');
}


/**
 * Returns a promise whose resolution will return an mbtile with the requested bounds.
 * @param bounds
 * @returns {Promise} the MBTile bounds
 */
var getMBTile = function (bounds) {
  return new Promise(function (resolve, reject) {
    console.log("Processing MBTiles for bounds:" + JSON.stringify(bounds));
    // Create temporary sqlite DB file
    var d = new Date();
    var dbFile = 'data/' + d.getTime() + '.sqlite';
    var db = new sqlite3.Database(dbFile);

    fs.readFile('conf/schema.sql', 'utf8', function (err, data) {
      if (err) {
        console.error('Error while loading schema: ' + err);
        throw err;
      }
      createTables(db, data)
          .then(function () {
            // required MetaData for mbtiles spec
            var metaData = {
              "name": "Mapsquare MBTile",
              "type": "baselayer",
              "version": 1,
              "description": "Base Layer generated by Mapsquare",
              "format": "png",
              "bounds": bounds.left + ',' + bounds.bottom + ',' + bounds.right + ',' + bounds.top
            };
            // Insert metadata into db
            return insertMetadata(db, metaData);
          })
          .then(function () {
            // Fetch then store tiles
            return fetchAndStoreTiles(bounds, db);
          })
          .then(function () {
            // All tiles have been stored. Close db.
            db.close(function () {
              console.log('MBTile computed successfully. File output is available in ' + dbFile);

              // Open file, send binary data to client, and remove file.
              fs.readFile(dbFile, function (err, data) {
                resolve(data);
              });
            });
            
          })
    });
  });
};

/**
 * Create mbtiles tables
 * @param db the database
 * @param data the queries to execute
 * @returns {Promise}
 */
var createTables = function (db, data) {
  return new Promise(function (resolve, reject) {
    db.exec(data, function () {
      resolve();
    });
  });
};

/**
 * Insert metadata into mbtile
 * @param db the database
 * @param metaData the metadata object
 * @returns {Promise}
 */
var insertMetadata = function (db, metaData) {
  return new Promise(function (resolve, reject) {
    debug('Inserting Metadata');
    db.serialize(function () {
      var stmt = db.prepare('INSERT INTO metadata VALUES (?, ?)');
      for (var key in metaData) {
        stmt.run(key, metaData[key]);
      }
      stmt.finalize();
      debug('Metadata inserted successfully.');
    });
    resolve();
  });
};

/**
 * Insert a tile using an sqlite statement
 * @param stmt the statement
 * @param tile the tile metadata
 * @param data the tile blob 
 * @param callback once it is done
 */
var insertTile = function (stmt, tile, data, callback) {
  debug('Inserting Tile');
  stmt.run(tile.z, tile.x, Math.pow(2, tile.z) - tile.y - 1, data);
  callback();
};

/**
 * Process step by step fetch of tiles and parallel store into db
 * @param bounds the requested bounds
 * @param db the database
 * @returns {Promise} a promise resolved when finished.
 */
var fetchAndStoreTiles = function (bounds, db) {
  return new Promise(function (resolve, reject) {
    // List tiles
    var tiles = listTiles(bounds);
    console.log(tiles.length + " tiles to process.");
    
    // Prepare steps
    var steps = [];
    
    for (var s = 0; s < Math.floor(1 + tiles.length / STEP_REQUEST_SIZE); s++) {
      var stmt = db.prepare('INSERT INTO tiles VALUES (?, ?, ?, ?)');
      // Use closures to split the tile fetch into sets, to prevent overflows (10000s of http requests at the same time).
      steps.push(fetchTilesFunction(tiles.slice(s * STEP_REQUEST_SIZE, Math.min((s + 1) * STEP_REQUEST_SIZE, tiles.length)), stmt));
      steps.push(closeStatementFunction(stmt));
    }
    // Last step is resolution
    steps.push(function () {
      debug('Rendering done');
      resolve();
    });

    // Launch processing
    Step.apply(this, steps);

  });
};

/**
 * Make a list of the necessary tiles to compute and embed into the mbtile according to bounds.
 * @param bounds the requested bounds
 * @returns {Array} the array of tiles
 */
var listTiles = function (bounds) {
  debug('Listing tiles for bounds' + JSON.stringify(bounds));
  var tiles = [];
  for (var z = Conf.minZoom; z <= Conf.maxZoom; z++) {
    var coords1 = ProjectionUtils.latLngToTileXYForZoom(bounds.top, bounds.left, z);
    var coords2 = ProjectionUtils.latLngToTileXYForZoom(bounds.bottom, bounds.right, z);
    // Adjust to process at least one tile for each zoom (lower zoom levels)
    if (coords1[0] === coords2[0]) {
      coords2[0] += 1;
    }
    if (coords1[1] === coords2[1]) {
      coords2[1] += 1;
    }
    
    for (var x = Math.min(coords1[0], coords2[0]); x < Math.max(coords1[0], coords2[0]); x++) {
      for (var y = Math.min(coords1[1], coords2[1]); y < Math.max(coords1[1], coords2[1]); y++) {
        var t = new Tile(x, y, z, mapper.getExtension());
        tiles.push(t);
      }
    }
  }
  return tiles;

};

/**
 * Closure for tile fetch
 * @param tiles the set of tiles to fetch
 * @param stmt the statement to run queries in
 * @returns {Function} the function
 */
var fetchTilesFunction = function (tiles, stmt) {
  return function () {
    var group = this.group();
    tiles.forEach(function (t) {
      var next = group();
      fetchTile(t, 0, function (data) {
        // Once fetch is done, store tile
        insertTile(stmt, t, data, next);
      });
    });
  };

};

/**
 * Closure for statement finalization
 * @param stmt the statement to close
 * @returns {Function} the function
 */
var closeStatementFunction = function (stmt) {
  return function () {
    stmt.finalize();
    this();
  }
};

/**
 * Make an http request to get a particular tile from the tileserver. Will attempt 3 times if request fails.
 * @param t the requested tile
 * @param attempts the number of failed attempts (< 3)
 * @param callback the callback once tile is fetched
 */
var fetchTile = function (t, attempts, callback) {
  var url = mapper.getTileUrl(t);
  debug("Getting " + url);
  http.get(url, function (res) {
    if (res.statusCode == 200) {
      res.setEncoding('base64');
      var body = '';
      res.on('data', function (chunk) {
        body += chunk;
      });
      res.on('end', function () {
        var blob = new Buffer(body, 'base64');
        // Store tile in sqlite db
        callback(blob);
      })
    } else {
      var error = {statusCode: res.statusCode, message: res.body};
      console.error('Received error from server' + JSON.stringify(error));
      // Will retry 3 times if error occured (maybe tile is not ready yet), fail beyond.
      if (attempts < 3) {
        fetchTile(t, attempts++, callback);
      }
    }
  }).on('error', function(err) {
    console.error('Received error from server' + JSON.stringify(err));
    // Will retry 3 times if error occured (maybe tile is not ready yet), fail beyond.
    if (attempts < 3) {
      fetchTile(t, attempts++, callback);
    }
  });
};

// Init
fs.mkdir('data', function(err) {
  if (err && err.code != 'EEXIST') {
    console.error(err);
  }
});

// Exports
module.exports.getMBTile = getMBTile;